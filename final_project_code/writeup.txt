For my final project, I chose to expand upon the basic idea I had for the particle assignment. I decided to create another N-Body simulation, but I wanted to make it much larger in size. Origionally, I wanted to use the barnes-hut spatial partitioning algorithm to speed up performace, in which an octree is used to divide space up and reduce the computational complexity of the simulation. Generally, this step is implemented on the CPU and can therefore be CPU bound. For this reason, I decided to implement the simulation from scratch using Rust instead of javascript and using WGPU, which is a library for rust that provides webgpu functionality. In the end, I could not get the barnes-hut algorithm implemented well enough to give better performance than the simple O(N^2) particle-particle algorithm, so I decided to stick to the simple algorithm as I found it was suprisingly fast (the demo videos are real-time and consist of 100,000 particles running the O(N^2) algorithm). 

To optimize the shaders, I used NVIDIA NSIGHT Graphics, which is able to do perfomance benchmarking on shaders. This was made possible by the fact that WGPU can use the Vulkan backend when compiled natively, allowing me to compile the shaders to SPIR-V and run local perfomance benchmarking. Optimizations mostly consisted of batching memory reads to attain better cache locality and to speed up similar memory access patterns within the same workgroups.

Visually, I sort of just wanted to see how the simulation progressed with different mass distributions and distance parameters. The particles are rendered to a texture using the point-rendering mode of the GPU, and then a blur is applied over them to give them more shape. I would have liked to implement better bloom effects for areas of lots of particles with scaled bloom textures, but I could not implement efficent mip-map generation and bloom shaders before the demo. In the future I would like to implement a proper UI (this is already mostly implemented using the eGUI library, which is similar to the more common imGUI library), and get the simulation hosted on my website. The simulation currently builds and runs on the web, but it appears that I need to host it on a SSL-signed website in order to load it beyond the local network (webassembly requirement).

Overall, I found the project extremely fun to implement. I liked working directly with the graphics api in a lower level language like run, and it has inspired me to do more similar projects in the future.